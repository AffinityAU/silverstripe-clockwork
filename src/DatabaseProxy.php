<?php
/**
 * Wraps the real database adapter, passing on most function calls
 * and logging queries for sending along to Clockwork
 *
 * @author Mark Guinn <mark@adaircreative.com>
 * @date 11.07.2014
 * @package clockwork
 */

namespace Clockwork\Support\Silverstripe;

use SS_Query;
use SS_Database;

class DatabaseProxy extends SS_Database
{
    /** @var SS_Database */
    protected $realConn;

    /** @var array */
    protected $queries;


    /**
     * @param SS_Database $realConn
     */
    public function __construct($realConn) {
        $this->realConn = $realConn;
        $this->queries = array();
    }


    /**
     * Execute the given SQL query.
     * This function must be defined by subclasses as part of the actual implementation.
     * It should return a subclass of SS_Query as the result.
     * @param string $sql     The SQL query to execute
     * @param int $errorLevel The level of error reporting to enable for the query
     * @return SS_Query
     */
    public function query($sql, $errorLevel = E_USER_ERROR) {
        $starttime = microtime(true);
        $handle = $this->realConn->query($sql, $errorLevel);
        $endtime = microtime(true);
        $this->queries[] = array('query' => $sql, 'duration' => round(($endtime - $starttime) * 1000.0, 2));
        return $handle;
    }


    /**
     * @return array
     */
    public function getQueries() {
        return $this->queries;
    }


    /**
     * @param string $name
     * @param array $arguments
     * @return mixed
     */
    public function __call($name, $arguments) {
        return call_user_func_array(array($this->realConn, $name), $arguments);
    }


    /**
     * Get the autogenerated ID from the previous INSERT query.
     * @return int
     */
    public function getGeneratedID($table) {
        return $this->realConn->getGeneratedID($table);
    }


    /**
     * Check if the connection to the database is active.
     * @return boolean
     */
    public function isActive() {
        return $this->realConn->isActive();
    }


    /**
     * Create the database and connect to it. This can be called if the
     * initial database connection is not successful because the database
     * does not exist.
     *
     * It takes no parameters, and should create the database from the information
     * specified in the constructor.
     *
     * @return boolean Returns true if successful
     */
    public function createDatabase() {
        return $this->realConn->createDatabase();
    }


    /**
     * Build the connection string from input
     * @param array $parameters The connection details
     * @return string $connect The connection string
     **/
    public function getConnect($parameters) {
        return $this->realConn->getConnect($parameters);
    }


    /**
     * Create a new table.
     * @param $tableName The name of the table
     * @param $fields    A map of field names to field types
     * @param $indexes   A map of indexes
     * @param $options   An map of additional options.  The available keys are as follows:
     *                   - 'MSSQLDatabase'/'MySQLDatabase'/'PostgreSQLDatabase' - database-specific options such as "engine" for MySQL.
     *                   - 'temporary' - If true, then a temporary table will be created
     * @return The table name generated.  This may be different from the table name, for example with temporary tables.
     */
    public function createTable(
        $table,
        $fields = null,
        $indexes = null,
        $options = null,
        $advancedOptions = null
    ) {
        return $this->realConn->createTable($table, $fields, $indexes, $options, $advancedOptions);
    }


    /**
     * Alter a table's schema.
     */
    public function alterTable(
        $table,
        $newFields = null,
        $newIndexes = null,
        $alteredFields = null,
        $alteredIndexes = null,
        $alteredOptions = null,
        $advancedOptions = null
    ) {
        return $this->realConn->alterTable($table, $newFields, $newIndexes,
            $alteredFields, $alteredIndexes, $alteredOptions, $advancedOptions);
    }


    /**
     * Rename a table.
     * @param string $oldTableName The old table name.
     * @param string $newTableName The new table name.
     */
    public function renameTable($oldTableName, $newTableName) {
        return $this->realConn->renameTable($oldTableName, $newTableName);
    }


    /**
     * Create a new field on a table.
     * @param string $table Name of the table.
     * @param string $field Name of the field to add.
     * @param string $spec  The field specification, eg 'INTEGER NOT NULL'
     */
    public function createField($table, $field, $spec) {
        return $this->realConn->createField($table, $field, $spec);
    }


    /**
     * Change the database column name of the given field.
     *
     * @param string $tableName The name of the tbale the field is in.
     * @param string $oldName   The name of the field to change.
     * @param string $newName   The new name of the field
     */
    public function renameField($tableName, $oldName, $newName) {
        return $this->realConn->renameField($tableName, $oldName, $newName);
    }


    /**
     * Get a list of all the fields for the given table.
     * Returns a map of field name => field spec.
     * @param string $table The table name.
     * @return array
     */
    protected function fieldList($table) {
        return $this->realConn->fieldList($table);
    }


    protected function tableList() {
        return $this->realConn->tableList();
    }


    /**
     * Returns true if the given table exists in the database
     */
    public function hasTable($tableName) {
        return $this->realConn->hasTable($tableName);
    }


    /**
     * Returns the enum values available on the given field
     */
    public function enumValuesForField($tableName, $fieldName) {
        return $this->realConn->enumValuesForField($tableName, $fieldName);
    }


    /**
     * Returns an escaped string.
     *
     * @param string
     * @return string - escaped string
     */
    public function addslashes($val) {
        return $this->realConn->addslashes($val);
    }


    /**
     * Generate a WHERE clause for text matching.
     *
     * @param String $field          Quoted field name
     * @param String $value          Escaped search. Can include percentage wildcards.
     * @param boolean $exact         Exact matches or wildcard support.
     * @param boolean $negate        Negate the clause.
     * @param boolean $caseSensitive Perform case sensitive search.
     * @return String SQL
     */
    public function comparisonClause($field, $value, $exact = false, $negate = false, $caseSensitive = false) {
        return $this->realConn->comparisonClause($field, $value, $exact, $negate, $caseSensitive);
    }


    /**
     * function to return an SQL datetime expression that can be used with the adapter in use
     * used for querying a datetime in a certain format
     * @param string $date   to be formated, can be either 'now', literal datetime like '1973-10-14 10:30:00' or
     *                       field name, e.g. '"SiteTree"."Created"'
     * @param string $format to be used, supported specifiers:
     *                       %Y = Year (four digits)
     *                       %m = Month (01..12)
     *                       %d = Day (01..31)
     *                       %H = Hour (00..23)
     *                       %i = Minutes (00..59)
     *                       %s = Seconds (00..59)
     *                       %U = unix timestamp, can only be used on it's own
     * @return string SQL datetime expression to query for a formatted datetime
     */
    public function formattedDatetimeClause($date, $format) {
        return $this->realConn->formattedDatetimeClause($date, $format);
    }


    /**
     * function to return an SQL datetime expression that can be used with the adapter in use
     * used for querying a datetime addition
     * @param string $date     , can be either 'now', literal datetime like '1973-10-14 10:30:00' or field name,
     *                         e.g. '"SiteTree"."Created"'
     * @param string $interval to be added, use the format [sign][integer] [qualifier], e.g. -1 Day, +15 minutes,
     *                         +1 YEAR
     *                         supported qualifiers:
     *                         - years
     *                         - months
     *                         - days
     *                         - hours
     *                         - minutes
     *                         - seconds
     *                         This includes the singular forms as well
     * @return string SQL datetime expression to query for a datetime (YYYY-MM-DD hh:mm:ss) which is the result of
     *                         the addition
     */
    public function datetimeIntervalClause($date, $interval) {
        return $this->realConn->datetimeIntervalClause($date, $interval);
    }


    /**
     * function to return an SQL datetime expression that can be used with the adapter in use
     * used for querying a datetime substraction
     * @param string $date1  , can be either 'now', literal datetime like '1973-10-14 10:30:00' or field name
     *                       e.g. '"SiteTree"."Created"'
     * @param string $date2  to be substracted of $date1, can be either 'now', literal datetime
     *                       like '1973-10-14 10:30:00' or field name, e.g. '"SiteTree"."Created"'
     * @return string SQL datetime expression to query for the interval between $date1 and $date2 in seconds which
     *                       is the result of the substraction
     */
    public function datetimeDifferenceClause($date1, $date2) {
        return $this->realConn->datetimeDifferenceClause($date1, $date2);
    }


    /**
     * Can the database override timezone as a connection setting,
     * or does it use the system timezone exclusively?
     *
     * @return Boolean
     */
    public function supportsTimezoneOverride() {
        return $this->realConn->supportsTimezoneOverride();
    }


    public function supportsTransactions() {
        return $this->realConn->supportsTransactions();
    }


    public function transactionStart($transaction_mode = false, $session_characteristics = false) {
        return $this->realConn->transactionStart($transaction_mode, $session_characteristics);
    }


    public function transactionSavepoint($savepoint) {
        return $this->realConn->transactionSavepoint($savepoint);
    }


    public function transactionRollback($savepoint = false) {
        return $this->realConn->transactionRollback($savepoint);
    }


    public function transactionEnd() {
        return $this->realConn->transactionEnd();
    }
}
